const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');

const dataDir = path.join(__dirname, '../data');
const streakFile = path.join(dataDir, 'streakData.json');
const statsFile = path.join(dataDir, 'statsData.json');

// JSONBin.io configuration
const JSONBIN_BASE_URL = 'https://api.jsonbin.io/v3/b';
const JSONBIN_API_KEY = process.env.JSONBIN_API_KEY || 'your-jsonbin-api-key';
const STATS_BIN_ID = process.env.STATS_BIN_ID || 'your-stats-bin-id';

// Cache variables
let cachedStatsData = null;
let cachedStreakData = null;
let lastCloudFetch = 0;
const CACHE_DURATION = 30000; // 30 seconds

async function ensureDataDir() {
  try {
    await fs.access(dataDir);
  } catch {
    await fs.mkdir(dataDir, { recursive: true });
  }
}

async function loadData(filePath) {
  try {
    await ensureDataDir();
    const data = await fs.readFile(filePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    console.log('No local data file found:', error.message);
    return null;
  }
}

async function saveData(filePath, data) {
  await ensureDataDir();
  await fs.writeFile(filePath, JSON.stringify(data, null, 2));
}

// Cloud storage functions
async function loadFromCloud(binId) {
  try {
    if (!JSONBIN_API_KEY || JSONBIN_API_KEY === 'your-jsonbin-api-key') {
      throw new Error('JSONBIN_API_KEY not configured');
    }
    
    const response = await axios.get(`${JSONBIN_BASE_URL}/${binId}/latest`, {
      headers: {
        'X-Master-Key': JSONBIN_API_KEY,
        'X-Bin-Meta': false
      }
    });
    
    return response.data;
  } catch (error) {
    console.log('Error loading from cloud:', error.message);
    throw new Error('Failed to load data from cloud storage');
  }
}

async function saveToCloud(binId, data) {
  try {
    if (!JSONBIN_API_KEY || JSONBIN_API_KEY === 'your-jsonbin-api-key') {
      throw new Error('JSONBIN_API_KEY not configured');
    }
    
    await axios.put(`${JSONBIN_BASE_URL}/${binId}`, data, {
      headers: {
        'Content-Type': 'application/json',
        'X-Master-Key': JSONBIN_API_KEY
      }
    });
    
    console.log('Data saved to cloud storage successfully');
    return true;
  } catch (error) {
    console.log('Failed to save to cloud:', error.message);
    throw new Error('Failed to save data to cloud storage');
  }
}

async function loadStreakData(forceRefresh = false) {
  try {
    const now = Date.now();
    
    // Return cached data if not forcing refresh and cache is still valid
    if (!forceRefresh && cachedStreakData && (now - lastCloudFetch) < CACHE_DURATION) {
      return cachedStreakData;
    }
    
    // Load everything from stats bin
    const allData = await loadStatsData(forceRefresh);
    
    // Extract streak data from stats
    if (allData && allData.streakData) {
      cachedStreakData = allData.streakData;
    } else {
      // If no streak data in bin, try to load from local file
      cachedStreakData = await loadData(streakFile);
      if (!cachedStreakData) {
        throw new Error('No streak data available in cloud or local storage');
      }
    }
    
    lastCloudFetch = now;
    return cachedStreakData;
  } catch (error) {
    console.error('Error loading streak data:', error.message);
    
    // Fall back to local storage
    const localData = await loadData(streakFile);
    if (localData) {
      return localData;
    }
    
    throw new Error('No streak data available');
  }
}

async function saveStreakData(data) {
  data.lastManualUpdate = new Date().toDateString();
  
  try {
    // Load current stats data
    const statsData = await loadStatsData();
    
    // Update streak data within stats
    statsData.streakData = data;
    statsData.lastUpdated = new Date().toISOString();
    
    // Save everything to cloud
    await saveToCloud(STATS_BIN_ID, statsData);
    
    // Also save locally as backup
    await saveData(statsFile, statsData);
    await saveData(streakFile, data);
    
    // Update cache
    cachedStatsData = statsData;
    cachedStreakData = data;
    lastCloudFetch = Date.now();
    
    return true;
  } catch (error) {
    console.error('Error saving streak data to cloud:', error.message);
    
    // Fall back to local storage only
    try {
      await saveData(streakFile, data);
      cachedStreakData = data;
      return true;
    } catch (localError) {
      console.error('Error saving to local storage:', localError.message);
      throw new Error('Failed to save streak data');
    }
  }
}

async function loadStatsData(forceRefresh = false) {
  try {
    const now = Date.now();
    
    // Return cached data if not forcing refresh and cache is still valid
    if (!forceRefresh && cachedStatsData && (now - lastCloudFetch) < CACHE_DURATION) {
      return cachedStatsData;
    }
    
    // Try to load from cloud first
    cachedStatsData = await loadFromCloud(STATS_BIN_ID);
    
    lastCloudFetch = now;
    return cachedStatsData;
  } catch (error) {
    console.error('Error loading stats data from cloud:', error.message);
    
    // Fall back to local storage
    const localData = await loadData(statsFile);
    if (localData) {
      cachedStatsData = localData;
      return localData;
    }
    
    throw new Error('No stats data available in cloud or local storage');
  }
}

async function saveStatsData(data) {
  data.lastUpdated = new Date().toISOString();
  
  try {
    // Save to cloud
    await saveToCloud(STATS_BIN_ID, data);
    
    // Also save locally as backup
    await saveData(statsFile, data);
    
    // Update cache
    cachedStatsData = data;
    lastCloudFetch = Date.now();
    
    return true;
  } catch (error) {
    console.error('Error saving stats data to cloud:', error.message);
    
    // Fall back to local storage only
    try {
      await saveData(statsFile, data);
      cachedStatsData = data;
      return true;
    } catch (localError) {
      console.error('Error saving to local storage:', localError.message);
      throw new Error('Failed to save stats data');
    }
  }
}

// Token management functions
async function saveStravaTokens(tokens) {
  try {
    const statsData = await loadStatsData();
    statsData.stravaTokens = tokens;
    statsData.lastUpdated = new Date().toISOString();
    
    await saveStatsData(statsData);
    
    // Also update environment variables for current session
    if (tokens.accessToken) process.env.ACCESS_TOKEN = tokens.accessToken;
    if (tokens.refreshToken) process.env.REFRESH_TOKEN = tokens.refreshToken;
    if (tokens.expiresAt) process.env.EXPIRES_AT = tokens.expiresAt;
    
    return true;
  } catch (error) {
    console.error('Error saving tokens:', error);
    return false;
  }
}

async function getStravaTokens() {
  try {
    const statsData = await loadStatsData();
    return statsData.stravaTokens || {};
  } catch (error) {
    console.error('Error loading tokens:', error);
    return {};
  }
}

// Webhook config functions
async function getWebhookConfig() {
  try {
    const statsData = await loadStatsData();
    return statsData.webhookConfig || {};
  } catch (error) {
    console.error('Error loading webhook config:', error);
    return {};
  }
}

module.exports = {
  loadStreakData,
  saveStreakData,
  loadStatsData,
  saveStatsData,
  saveStravaTokens,
  getStravaTokens,
  getWebhookConfig
};
